#ifndef MATERIALX_MAYA_LOBEPRUNER_H
#define MATERIALX_MAYA_LOBEPRUNER_H

/// @file
/// Helpers

#include "MaterialXCore/Definition.h"
#include "MaterialXCore/Library.h"
#include "MaterialXCore/Node.h"
#include "pxr/base/tf/token.h"

#include <mayaUsd/base/api.h>

#include <pxr/base/tf/token.h>
#include <pxr/imaging/hd/material.h>
#include <pxr/pxr.h>

#include <MaterialXCore/Document.h>
#include <MaterialXCore/Node.h>

#include <memory>
#include <string>

namespace mx = MaterialX;
namespace MaterialXMaya {
namespace ShaderGenUtil {

/*! \brief  This class will process MaterialX surface shader nodes and provide optimized version of
 * the shader based on the current value of a node attribute.
 */
class LobePrunerImpl;
class MAYAUSD_CORE_PUBLIC LobePruner
{
public:
    using Ptr = std::shared_ptr<LobePruner>;
    /*! Creates a shared LobePruner.
     *  \return the freshly created LobePruner.
     */
    static Ptr create();

    LobePruner();
    ~LobePruner();

    LobePruner(const LobePruner&) = delete;
    LobePruner& operator=(const LobePruner&) = delete;
    LobePruner(LobePruner&&) = delete;
    LobePruner& operator=(LobePruner&&) = delete;

    /*! Sets the LobePruner library. This is used first to explore all surface shaders for
     * optimization candidated, then to store the optimized NodeDef and NodeGraph this class
     * generates.
     * @param[in] library is a fully loaded MaterialX library where the generated optimized shaders
     * will be stored.
     */
    void setLibrary(const mx::DocumentPtr& library);

    /*! Checks if a node is optimizable and if this is the case, create the optimized NodeDef and
     * NodeGraph in the library and return the optimized node category.  An optimized node category
     * will consist of the name of the original category followed by a series of characters
     * describing which attibutes were optimized:
     *   - 'x' that attribute was not optimized (intermediate value or connected)
     *   - '0' a zero value was optimized
     *   - '1' a one value was optimized
     * The ordered list of attributes names can be found by calling getOptimizedAttributeNames().
     * @param[in] node is a node we want to optimize. All nodes are welcome.
     * @param[out] nodeCategory is the node category of the optimized node.
     *  \return true if an optimization was found
     */
    bool getOptimizedNodeCategory(const mx::Node& node, std::string& nodeCategory);

    /*! Get the list of attribute names that are optimization targets for a specific NodeDef.
     * @param[in] nodeDef is preferably node definition that has previously been optimized, but all
     * definitions are welcome.
     * \return a vector of strings containing the list of attributes that
     * are used to generate an optimized version of this shader. Empty if the LobePruner can not
     * optimize it.
     */
    mx::StringVec getOptimizedAttributeNames(const mx::NodeDefPtr& nodeDef) const;

    /*! USD specific. Checks if a node is optimizable and if this is the case, create the optimized
     * NodeDef and NodeGraph in the library and return the optimized node id. An optimized node id
     * will be built from the name of the original category followed by a series of characters
     * describing which attibutes were optimized:
     *   - 'x' that attribute was not optimized (intermediate value or connected)
     *   - '0' a zero value was optimized
     *   - '1' a one value was optimized
     * The ordered list of attributes names can be found by calling getOptimizedAttributeNames().
     * @param[in] node is a node we want to optimize. All nodes are welcome.
     *  \return a TfToken with the optimized node:id if one was found, will return the Empty token
     * if no optimization was found.
     */
    PXR_NS::TfToken getOptimizedNodeId(const PXR_NS::HdMaterialNode2& node);

    /*! USD specific. Checks if a node id was created by the LobePruner.
     * @param[in] nodeId is a node:id we want to check.
     *  \return true if that node was generated by a LobePruner.
     */
    static bool isOptimizedNodeId(const PXR_NS::TfToken& nodeId);

    /*! Returns the NodeDef prefix common to all LobePruner optimized definitions.
     *  \return the LobePruner NodeDef prefix
     */
    static const std::string& getOptimizedNodeDefPrefix();

    /*! Returns the node category of an optimized dark PBR node used to replace any base PBR node
     * that has a weight of zero.
     * \return the Node category
     */
    static const std::string& getDarkBaseNodeName();

    /*! Returns the node category of an optimized dark PBR node used to replace any layered PBR node
     * that has a weight of zero.
     * \return the Node category
     */
    static const std::string& getDarkLayerNodeName();

    /*! Returns the node definition name of an optimized dark PBR node used to replace any base PBR
     * node that has a weight of zero.
     * \return the NodeDef name
     */
    static const std::string& getDarkBaseNodeDefName();

    /*! Returns the node definition name of an optimized dark PBR node used to replace any layered
     * PBR node that has a weight of zero.
     * \return the NodeDef name
     */
    static const std::string& getDarkLayerNodeDefName();

    /*! Returns the implementation name of an optimized dark PBR node used to replace any base PBR
     * node that has a weight of zero. It is the responsibility of the shadergen code to provide a
     * working implementation.
     * \return the Implementation name
     */
    static const std::string& getDarkBaseImplementationName();

    /*! Returns the implementation name of an optimized dark PBR node used to replace any base PBR
     * node that has a weight of zero. It is the responsibility of the shadergen code to provide a
     * working implementation.
     \return the Implementation name
     */
    static const std::string& getDarkLayerImplementationName();

protected:
    std::unique_ptr<LobePrunerImpl> _impl;
};

} // namespace ShaderGenUtil
} // namespace MaterialXMaya

#endif
