-- glslfx version 0.1

//
// Copyright 2018 Pixar
//
// Licensed under the Apache License, Version 2.0 (the "Apache License")
// with the following modification; you may not use this file except in
// compliance with the Apache License and the following modification to it:
// Section 6. Trademarks. is deleted and replaced with:
//
// 6. Trademarks. This License does not grant permission to use the trade
//    names, trademarks, service marks, or product names of the Licensor
//    and its affiliates, except as required to comply with Section 4(c) of
//    the License and to reproduce the content of the NOTICE file.
//
// You may obtain a copy of the Apache License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the Apache License with the above modification is
// distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied. See the Apache License for the specific
// language governing permissions and limitations under the Apache License.
//

-- configuration
{
    "techniques": {
        "default": {
            "vertexShader" : {
                "source": [
                    "MayaStipple.Global",
                    "MayaStipple.Vertex" 
                    ]
            },
            "fragmentShader" : {
                "source": [ 
                    "MayaStipple.Global",
                    "MayaStipple.Fragment"
                    ]
            }
        }
    }
}

-- glsl MayaStipple.Global


//  Globals 
uniform mat4 WorldViewProj : worldviewprojection; 
uniform mat4 World : world; 
uniform mat4 WorldIT : worldinversetranspose; 
uniform float DepthPriority : DepthPriority; 
uniform bool orthographic : isorthographic; 
uniform float depthPriorityThreshold : mayadepthprioritythreshold; 
uniform float depthPriorityScale : mayadepthprioirtyscale; 


//  Globals 
uniform texture2D map; 
uniform sampler2D samp= sampler_state
{ 
    Texture = <map>; 
};

uniform vec2 mayaTextureSize={ 16.000000, 16.000000 }; 
uniform vec2 screenSize : viewportPixelSize; 
uniform vec4 solidColor={ 1.000000, 1.000000, 1.000000, 1.000000 }; 
uniform vec4 selectionHiddenColor={ -1.000000, -1.000000, -1.000000, 1.000000 }; 
uniform bool isSelectionHighlightingON=1; 
uniform float alphaDiscardThreshold=0.050000; 
uniform bool enableXRayComp : enableXRayComp; 
uniform bool forceAlphaAdjust=0; 
uniform vec3 cameraPosition : worldcameraposition; 
uniform float mayaFrontFaceAlpha=1.000000; 
uniform float mayaBackFaceAlpha=0.000000;

-- glsl MayaStipple.Vertex


//  Declarations 

// vertexInS

attribute vec3 Pm;

attribute vec3 Nm;

// vertOutS

attribute vec3 U0;

attribute vec3 Pw;

attribute vec3 Nw;


vec3 iScreenCoord2TexCoord( vec3 pm, mat4x4 worldViewProjectionC)
{	 
    vec4 pc = mul( worldViewProjectionC, vec4(pm,1.0f) ); 
    return pc.xyw; 
} 

vec4 iPcPriority( vec3 pm, mat4x4 worldViewProjectionC, 
     float depthPriority, bool orthographic, float DPThresholdInView, float dpScale)
{ 
    vec4 pos = mul( worldViewProjectionC, vec4(pm, 1.0f) ); 
    if (orthographic) {
		pos.z -= 2.0f * depthPriority * dpScale; 
		return pos; 
	 }
	 if (pos.z > 0) pos.z -= pos.w < -DPThresholdInView ? 2.0f * depthPriority * pos.w : -DPThresholdInView * depthPriority; 
    return pos; 
} 

highp vec3 iPw( in vec3 pm, highp mat4 world ) 
{ 
    return ( world * vec4(pm, 1.0) ).xyz; 
} 

highp vec3 iNw(in vec3 nm, in highp mat4 worldITC) 
{ 
     return ( worldITC * vec4(nm,0.0) ).xyz; 
} 

void main(void)
{
    // ShaderBody 
    vec3 v_U04760 = iScreenCoord2TexCoord( Pm, WorldViewProj ); 
    U0 = v_U04760; 
    Pw = iPw( Pm, World ); 
    Nw = iNw( Nm, WorldIT ); 
    gl_Position = iPcPriority ( Pm, WorldViewProj, DepthPriority, orthographic, depthPriorityThreshold, depthPriorityScale ); 
}


-- glsl MayaStipple.Fragment

// fragInS
attribute vec3 U0;

attribute vec3 Pw;

attribute vec3 Nw;

// fragOutS
attribute vec4 ColorOut;

//  Fragments 
vec3 ScreenCoord2TexCoord( vec3 iUV0 )
{ 
    return iUV0; 
} 

vec4 texture2(  sampler2D mapSampler, vec3 uv, vec2 texSize, vec2 screenSize, vec4 activeColor, vec4 selectionHiddenColor, bool isSelectionHighlightingON, float alphaDiscardThreshold )
{ 
    vec4 colorUsed = isSelectionHighlightingON ? activeColor : (selectionHiddenColor.r < 0 ? activeColor : selectionHiddenColor); 
	vec2 tc = uv.xy / uv.z; 
	tc = (tc + 1.0) * 0.5; 
	tc = tc.xy * screenSize /texSize; 
    vec4 color = texture( mapSampler, tc);  
    color = vec4(color.rgb * colorUsed.rgb, color.r * colorUsed.a); 
    if(color.a < alphaDiscardThreshold) discard; 
    return color; 
} 

vec3 _Pw( in vec3 ipw )
{ 
    return ipw; 
} 

vec3 _Nw( in vec3 iNw )
{ 
    return normalize( iNw ); 
} 

vec4 alphaAdjust( vec4 finalColor,  bool enableXRayComp, bool forceAlphaAdjust, vec3 Pw, vec3 Nw, vec3 Ew, float FFAlpha, float BFAlpha ) 
{ 
	 if (forceAlphaAdjust || enableXRayComp) {
		vec3 EtP = Ew - Pw; 
		vec3 NorEtP = normalize(EtP); 
		vec3 NorNw = normalize(Nw); 
		float norDir = dot(NorEtP, NorNw); 
		finalColor.a = (norDir > 0.0f) ?  FFAlpha : BFAlpha; 
    }

    return finalColor; 
}

void main(void)
{
    // ShaderBody 
    vec3 v_U04760 = ScreenCoord2TexCoord( U0 ); 
    vec4 v_mayaUITextureVS4759 = texture2( samp, v_U04760, mayaTextureSize, screenSize, solidColor, selectionHiddenColor, isSelectionHighlightingON, alphaDiscardThreshold ); 
    vec3 v_Pw4764 = _Pw( Pw ); 
    vec3 v_Nw4765 = _Nw( Nw ); 
    vec4 v_mayaAlphaAdjustedByNormal4756 = alphaAdjust( v_mayaUITextureVS4759, enableXRayComp, forceAlphaAdjust, v_Pw4764, v_Nw4765, cameraPosition, mayaFrontFaceAlpha, mayaBackFaceAlpha ); 

    ColorOut = v_mayaAlphaAdjustedByNormal4756;
}