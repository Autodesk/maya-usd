#!/usr/bin/env python

#
# Copyright 2020 Autodesk
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

import os
import tempfile
import ufe
import unittest

import maya.cmds as cmds

import usdUtils, mayaUtils, testUtils

from cachingUtils import NonCachingScope, CachingScope
from ufeUtils import createUfeSceneItem, selectUfeItems
from mayaUtils import createProxyAndStage, createProxyFromFile, createAnimatedHierarchy

from mayaUsd import lib as mayaUsdLib
from mayaUsd.lib import GetPrim
from mayaUsd.lib import proxyAccessor as pa

from pxr import Usd, UsdGeom, Sdf, Tf, Vt

class MayaUsdProxyAccessorTestCase(unittest.TestCase):
    """
    Verify mayaUsd ProxyAccessor.
    """
    
    pluginsLoaded = False # Was mayaUsdPlugin loaded in this test class. Set in setUpClass.
    testDir = None # Folder where test files will be written. Set in setUpClass.
    testAnimatedHierarchyUsdFile = None # Usd file with content generated by createAnimatedHierarchy method
    cache_allFrames = [[1,120]] # Frames which have to be valid when entire cache is populated
    cache_empty = [] # Entire cache is invalid,
    
    @classmethod
    def setUpClass(cls):
        """
        Load mayaUsdPlugin on class initialization (before any test is executed)
        """
        if not cls.pluginsLoaded:
            cls.pluginsLoaded = mayaUtils.isMayaUsdPluginLoaded()
            cmds.loadPlugin('matrixNodes')
        
        # Useful for debugging accessor
        #Tf.Debug.SetDebugSymbolsByName("USDMAYA_PROXYACCESSOR", 1)
        
        cls.testDir = os.path.join(os.path.abspath('.'),'TestMayaUsdProxyAccessor')
        tmpUsdFile = os.path.join(cls.testDir,'AnimatedHierarchy.usda')
        
        layer = Sdf.Layer.CreateAnonymous('TmpLayer')
        stage = Usd.Stage.Open(layer.identifier)
        createAnimatedHierarchy(stage)
        layer.Export(tmpUsdFile)
        
        cls.testAnimatedHierarchyUsdFile = tmpUsdFile

    @classmethod
    def tearDownClass(cls):
        """
        Cleanup after all tests run
        """
        cmds.file(new=True, force=True)

    def setUp(self):
        """
        Called initially to set up the maya test environment
        """
        self.assertTrue(self.pluginsLoaded)
    
    def assertVectorAlmostEqual(self, a, b, places=7):
        """
        Helper for vector almost equal assert
        """
        for va, vb in zip(a, b):
            self.assertAlmostEqual(va, vb, places)

    def assertMatrixAlmostEqual(self, ma, mb):
        for ra, rb in zip(ma, mb):
            for a, b in zip(ra, rb):
                self.assertAlmostEqual(a, b)

    def validatePlugsEqual(self, node, plugsWithResults):
        for plug, expected in plugsWithResults:
            result = cmds.getAttr('{}.{}'.format(node,plug))
            self.assertEqual(result, [expected])

    def validatePlugsAlmostEqual(self, node, plugsWithResults):
        for plug, expected in plugsWithResults:
            result = cmds.getAttr('{}.{}'.format(node,plug))
            self.assertAlmostEqual(result, [expected])

    def validateOutput(self,cachingScope):
        """
        Validate that accessor can output attributes and worldspace matrix from the stage
        """
        nodeDagPath, stage = createProxyFromFile(self.testAnimatedHierarchyUsdFile)
        
        # Get UFE items
        ufeParentItemA = createUfeSceneItem(nodeDagPath,'/ParentA')
        ufeChildItemSphere = createUfeSceneItem(nodeDagPath,'/ParentA/Sphere')
        
        # Create accessor plugs
        worldMatrixPlugA = pa.getOrCreateAccessPlug(ufeParentItemA, '', Sdf.ValueTypeNames.Matrix4d )
        worldMatrixPlugSphere = pa.getOrCreateAccessPlug(ufeChildItemSphere, '', Sdf.ValueTypeNames.Matrix4d )
        translatePlugSphere = pa.getOrCreateAccessPlug(ufeChildItemSphere, usdAttrName='xformOp:translate' )
        
        cachingScope.waitForCache()
        cachingScope.checkValidFrames(self.cache_allFrames)
        
        # Validate output accessor plugs
        cmds.currentTime(1)
        v0 = cmds.getAttr('{}.{}'.format(nodeDagPath,worldMatrixPlugA))
        v1 = cmds.getAttr('{}.{}'.format(nodeDagPath,worldMatrixPlugSphere))
        v2 = cmds.getAttr('{}.{}'.format(nodeDagPath,translatePlugSphere))
        self.assertEqual(v0, [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0])
        self.assertEqual(v1, [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 5.0, 0.0, 0.0, 1.0])
        self.assertEqual(v2, [(5.0, 0.0, 0.0)])
        
        cmds.currentTime(100)
        v0 = cmds.getAttr('{}.{}'.format(nodeDagPath,worldMatrixPlugA))
        v1 = cmds.getAttr('{}.{}'.format(nodeDagPath,worldMatrixPlugSphere))
        v2 = cmds.getAttr('{}.{}'.format(nodeDagPath,translatePlugSphere))
        self.assertEqual(v0, [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 5.0, 0.0, 1.0])
        self.assertEqual(v1, [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, -5.0, 5.0, 0.0, 1.0])
        self.assertEqual(v2, [(-5.0, 0.0, 0.0)])

    def validateOutputForInMemoryRootLayer(self,cachingScope):
        """
        Validate that accessor can output attributes and worldspace matrix from the stage.
        This helper method is creating stage with in-memory root layer.
        """
        nodeDagPath,stage = createProxyAndStage()
        createAnimatedHierarchy(stage)
        
        # Get UFE items
        ufeParentItemA = createUfeSceneItem(nodeDagPath,'/ParentA')
        
        # Create accessor plugs
        worldMatrixPlugA = pa.getOrCreateAccessPlug(ufeParentItemA, '', Sdf.ValueTypeNames.Matrix4d )
        
        cachingScope.waitForCache()
        cachingScope.checkValidFrames(self.cache_allFrames)
        
        # Validate output accessor plugs
        cmds.currentTime(1)
        v0 = cmds.getAttr('{}.{}'.format(nodeDagPath,worldMatrixPlugA))
        self.assertEqual(v0, [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0])
        
        cmds.currentTime(100)
        v0 = cmds.getAttr('{}.{}'.format(nodeDagPath,worldMatrixPlugA))
        self.assertEqual(v0, [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 5.0, 0.0, 1.0])

    def validateTransformedOutput(self,cachingScope):
        """
        Validate that accessor will respect shape transform when writing world space outputs
        """
        nodeDagPath, stage = createProxyFromFile(self.testAnimatedHierarchyUsdFile)
        
        # Animate proxy shape transform
        transform = cmds.listRelatives(nodeDagPath,parent=True)[0]
        cmds.setKeyframe( '{}.ry'.format(transform), time=1.0, value=0 )
        cmds.setKeyframe( '{}.ry'.format(transform), time=100.0, value=90 )
        
        # Get UFE items
        ufeItemSphere = createUfeSceneItem(nodeDagPath,'/ParentA/Sphere')
        worldMatrixPlugSphere = pa.getOrCreateAccessPlug(ufeItemSphere, '', Sdf.ValueTypeNames.Matrix4d )
        
        cachingScope.waitForCache()
        cachingScope.checkValidFrames(self.cache_allFrames)
        
        # Validate that DAG transformation is applied when reading world space matrix from USD
        cmds.currentTime(1)
        v1 = cmds.getAttr('{}.{}'.format(nodeDagPath,worldMatrixPlugSphere))
        self.assertEqual(v1, [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 5.0, 0.0, 0.0, 1.0])
        
        cmds.currentTime(100)
        v1 = cmds.getAttr('{}.{}'.format(nodeDagPath,worldMatrixPlugSphere))
        self.assertVectorAlmostEqual(v1, [0.0, 0.0, -1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 5.0, 5.0, 1.0])

    def validateInput(self, cachingScope):
        """
        Validate that accessor can write data to the stage and it's propagated correctly to:
        - output plugs
        - UFE interfaces
        """
        nodeDagPath, stage = createProxyFromFile(self.testAnimatedHierarchyUsdFile)
        
        # Get UFE items
        ufeItemParent = createUfeSceneItem(nodeDagPath,'/ParentA')
        ufeItemSphere = createUfeSceneItem(nodeDagPath,'/ParentA/Sphere')
        ufeItemCube = createUfeSceneItem(nodeDagPath,'/ParentA/Cube')
        
        # Create accessor plugs
        translatePlugParent = pa.getOrCreateAccessPlug(ufeItemParent, usdAttrName='xformOp:translate')
        rotatePlugParent = pa.getOrCreateAccessPlug(ufeItemParent, usdAttrName='xformOp:rotateXYZ')
        worldMatrixPlugSphere = pa.getOrCreateAccessPlug(ufeItemSphere, '', Sdf.ValueTypeNames.Matrix4d)
        
        # Instanciate interface object for UFE transform3d
        ufeTransform3dCube = ufe.Transform3d.transform3d(ufeItemCube)
        
        # Animate accessor plugs (they will become inputs to the stage owned by proxy)
        cmds.setKeyframe( '{}.{}'.format(nodeDagPath,translatePlugParent), time=1.0, value=0.0 )
        cmds.setKeyframe( '{}.{}'.format(nodeDagPath,translatePlugParent), time=100.0, value=10.0)
        
        cmds.setKeyframe( '{}.{}'.format(nodeDagPath,rotatePlugParent), time=1.0, value=0.0 )
        cmds.setKeyframe( '{}.{}'.format(nodeDagPath,rotatePlugParent), time=100.0, value=90.0)
        
        # Validate that input accessor plugs wrote the data to USD
        # Validate that output accessor plug has data driven by input accessor plug
        
        cachingScope.checkValidFrames(self.cache_empty)
        cachingScope.waitForCache()
        cachingScope.checkValidFrames(self.cache_allFrames)
        
        cmds.currentTime(1)
        v1 = cmds.getAttr('{}.{}'.format(nodeDagPath,worldMatrixPlugSphere))
        v2 = ufeTransform3dCube.segmentInclusiveMatrix()
        self.assertEqual(v1, [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 5.0, 0.0, 0.0, 1.0])
        self.assertMatrixAlmostEqual(v2.matrix, [[1.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0], [0.0, 0.0, 5.0, 1.0]])
        
        cmds.currentTime(100)
        v1 = cmds.getAttr('{}.{}'.format(nodeDagPath,worldMatrixPlugSphere))
        v2 = ufeTransform3dCube.segmentInclusiveMatrix()
        self.assertVectorAlmostEqual(v1, [0.0, 0.0, -1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 10.0, 10.0, 15.0, 1.0])
        self.assertMatrixAlmostEqual(v2.matrix, [[0.0, 0.0, -1.0, 0.0], [0.0, 1.0, 0.0, 0.0], [1.0, 0.0, 0.0, 0.0], [5.0, 10.0, 10.0, 1.0]])

    def validateParentingDagObjectUnderUsdPrim(self, cachingScope):
        """
        Parent DagObject under UsdPrim
        """
        nodeDagPath,stage = createProxyFromFile(self.testAnimatedHierarchyUsdFile)
        
        # Animate proxy shape transform
        transform = cmds.listRelatives(nodeDagPath,parent=True)[0]
        cmds.setKeyframe( '{}.ry'.format(transform), time=1.0, value=0 )
        cmds.setKeyframe( '{}.ry'.format(transform), time=100.0, value=90 )
        
        # Create a locator to parent under /ParentA/Sphere
        # and apply offset on its translateY
        cmds.spaceLocator()
        childNodeDagPath = cmds.ls(sl=True,l=True)[0]
        cmds.setAttr('{}.ty'.format(childNodeDagPath), 3)
        
        # Get UFE items
        ufeItemSphere = createUfeSceneItem(nodeDagPath,'/ParentA/Sphere')
        ufeItemChild = createUfeSceneItem(childNodeDagPath)
        
        # Parent
        pa.parentItems([ufeItemChild],ufeItemSphere)
        
        # Validate
        cachingScope.checkValidFrames(self.cache_empty)
        cachingScope.waitForCache()
        cachingScope.checkValidFrames(self.cache_allFrames)
        
        cmds.currentTime(1)
        v1 = cmds.getAttr('{}.wm[0]'.format(childNodeDagPath))
        self.assertEqual(v1, [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 5.0, 3.0, 0.0, 1.0])
        
        cmds.currentTime(100)
        v1 = cmds.getAttr('{}.wm[0]'.format(childNodeDagPath))
        self.assertVectorAlmostEqual(v1, [0.0, 0.0, -1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 8.0, 5.0, 1.0])

    def validateSerialization(self,fileName, fileType):
        """
        Helper method for testing serialization.
        Test is a merge of DG connectivity and compute from testTransformedOutput, testInput and testParentingDagObjectUnderUsdPrim
        """
        nodeDagPath, stage = createProxyFromFile(self.testAnimatedHierarchyUsdFile)
        
        # Create a locator and parent under /ParentA/Sphere
        # Apply offset on its translateY
        cmds.spaceLocator()
        locatorNodeDagPath = cmds.ls(sl=True,l=True)[0]
        cmds.setAttr('{}.ty'.format(locatorNodeDagPath), 3)
        
        # Get UFE items
        ufeItemParent = createUfeSceneItem(nodeDagPath,'/ParentA')
        ufeItemSphere = createUfeSceneItem(nodeDagPath,'/ParentA/Sphere')
        ufeItemCube = createUfeSceneItem(nodeDagPath,'/ParentA/Cube')
        ufeItemLocator = createUfeSceneItem(locatorNodeDagPath)
        
        translatePlugParent = pa.getOrCreateAccessPlug(ufeItemParent, usdAttrName='xformOp:translate')
        rotatePlugParent = pa.getOrCreateAccessPlug(ufeItemParent, usdAttrName='xformOp:rotateXYZ')
        worldMatrixPlugSphere = pa.getOrCreateAccessPlug(ufeItemSphere, '', Sdf.ValueTypeNames.Matrix4d)
        
        # Animate proxy shape transform
        transform = cmds.listRelatives(nodeDagPath,parent=True)[0]
        cmds.setKeyframe( '{}.ry'.format(transform), time=1.0, value=0 )
        cmds.setKeyframe( '{}.ry'.format(transform), time=100.0, value=90 )
        
        # Animate ParentA Translate and Rotate input plugs
        cmds.setKeyframe( '{}.{}'.format(nodeDagPath,translatePlugParent), time=1.0, value=0.0 )
        cmds.setKeyframe( '{}.{}'.format(nodeDagPath,translatePlugParent), time=100.0, value=10.0)
        
        cmds.setKeyframe( '{}.{}'.format(nodeDagPath,rotatePlugParent), time=1.0, value=0.0 )
        cmds.setKeyframe( '{}.{}'.format(nodeDagPath,rotatePlugParent), time=100.0, value=90.0)
        
        pa.parentItems([ufeItemLocator],ufeItemSphere)
        
        # Validate state before save
        cmds.currentTime(1)
        v1 = cmds.getAttr('{}.{}'.format(nodeDagPath,worldMatrixPlugSphere))
        v2 = cmds.getAttr('{}.wm[0]'.format(locatorNodeDagPath)) # should be offset by 3 since we modified ty above
        self.assertEqual(v1, [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 5.0, 0.0, 0.0, 1.0])
        self.assertEqual(v2, [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 5.0, 3.0, 0.0, 1.0])
        
        cmds.currentTime(100)
        v1 = cmds.getAttr('{}.{}'.format(nodeDagPath,worldMatrixPlugSphere))
        v2 = cmds.getAttr('{}.wm[0]'.format(locatorNodeDagPath)) # should be offset by 3 since we modified ty above
        self.assertVectorAlmostEqual(v1, [-1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 15.0, 10.0, -10.0, 1.0])
        self.assertVectorAlmostEqual(v2, [-1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 15.0, 13.0, -10.0, 1.0])
        
        # Save and re-load the scene
        tmpMayaFile = os.path.join(self.testDir,fileName)
        cmds.file(rename=tmpMayaFile)
        cmds.file(save=True, type=fileType)
        cmds.file(new=True, force=True)
        cmds.file(tmpMayaFile, open=True, force=True)
        
        # Validate the saved scene
        cmds.currentTime(1)
        v1 = cmds.getAttr('{}.{}'.format(nodeDagPath,worldMatrixPlugSphere))
        v2 = cmds.getAttr('{}.wm[0]'.format(locatorNodeDagPath)) # should be offset by 3 since we modified ty above
        self.assertEqual(v1, [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 5.0, 0.0, 0.0, 1.0])
        self.assertEqual(v2, [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 5.0, 3.0, 0.0, 1.0])
        
        cmds.currentTime(100)
        v1 = cmds.getAttr('{}.{}'.format(nodeDagPath,worldMatrixPlugSphere))
        v2 = cmds.getAttr('{}.wm[0]'.format(locatorNodeDagPath)) # should be offset by 3 since we modified ty above
        self.assertVectorAlmostEqual(v1, [-1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 15.0, 10.0, -10.0, 1.0])
        self.assertVectorAlmostEqual(v2, [-1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 15.0, 13.0, -10.0, 1.0])

    def validatePassivelyAffectedReset(self, cachingScope):
        """
        This helper method will validate that temporary manipulation is properly
        reset when no keys were dropped after manipulation.
        """
        nodeDagPath, stage = createProxyFromFile(self.testAnimatedHierarchyUsdFile)
        
        # Get UFE item and select it
        ufeItemParent = createUfeSceneItem(nodeDagPath,'/ParentA')
        selectUfeItems(ufeItemParent)
        
        # We are going to manipulate animated prim. Let's make sure this opinion can be authored
        # since currently UFE will author attribute values at default time which won't override
        # attributes with time sampled data. Switching to session layer allows such manipulation
        # to override time sampled data from root layer.
        stage.SetEditTarget(stage.GetSessionLayer())

        # Current limitation requires access plugs to be created before we start manipulating and keying
        translatePlug = pa.getOrCreateAccessPlug(ufeItemParent, usdAttrName='xformOp:translate')
        rotatePlug = pa.getOrCreateAccessPlug(ufeItemParent, usdAttrName='xformOp:rotateXYZ')
        cmds.currentTime(1) # trigger compute to fill the data
        
        cachingScope.waitForCache()
        cachingScope.checkValidFrames(self.cache_allFrames)
        
        # Manipulate using Maya and key (at frame 1)
        cmds.currentTime(1)
        cmds.move(0,-2,0, relative=True)
        cmds.rotate(0, 90, 0, relative=True, objectSpace=True, forceOrderXYZ=True)

        cachingScope.checkValidFrames(self.cache_empty)

        # Proxy accessor should pick up the manipulation and write it to output plugs
        # This is important to enable keying workflow
        self.validatePlugsEqual(nodeDagPath,
            [(translatePlug,(0.0, -2.0, 0.0)), (rotatePlug, (0.0, 90.0, 0.0))])
        
        pa.keyframeAccessPlug(ufeItemParent, 'xformOp:translate')
        pa.keyframeAccessPlug(ufeItemParent, 'xformOp:rotateXYZ')
     
        # Double check that nothing changed after keying
        # Keying will create a new curve and connect the plug making
        # accessor plug an input now (since it has a connection)
        self.validatePlugsEqual(nodeDagPath,
            [(translatePlug,(0.0, -2.0, 0.0)), (rotatePlug, (0.0, 90.0, 0.0))])

        cachingScope.waitForCache()
        cachingScope.checkValidFrames(self.cache_allFrames)

        # Manipulate again, but this time we don't key
        # Expected result is that after time change we should get back previously
        # keyed value (as per regular animation workflow in Maya)
        cmds.move(20,20,20, relative=True)
        cmds.rotate(45, 0, 0, relative=True, objectSpace=True, forceOrderXYZ=True)
        
        # Because we already have animation connected to accessor plugs,
        # above manipulation should only passively affect the data coming from connections.
        # Until we key, this should not invalidate the cache and values should be reset
        # with dirty propagation (caused by curve manipulation or times change)
        cachingScope.checkValidFrames(self.cache_allFrames)
        
        self.validatePlugsEqual(nodeDagPath,
            [(translatePlug,(20.0, 18.0, 20.0)), (rotatePlug, (45.0, 90.0, 0.0))])
        
        cmds.currentTime(50) # this time change should reset the value
        self.validatePlugsEqual(nodeDagPath,
            [(translatePlug,(0.0, -2.0, 0.0)), (rotatePlug, (0.0, 90.0, 0.0))])

        # This reset shouldn't invalidate the cache
        cachingScope.checkValidFrames(self.cache_allFrames)

    def validateDagManipulation(self,cachingScope):
        """
        This helper method validate proper DAG invalidation during manipulation
        """
        nodeDagPath, stage = createProxyFromFile(self.testAnimatedHierarchyUsdFile)
        
        # Animate proxy shape transform
        transform = cmds.listRelatives(nodeDagPath,parent=True)[0]
        
        # Get UFE items
        ufeItemSphere = createUfeSceneItem(nodeDagPath,'/ParentA/Sphere')
        worldMatrixPlugSphere = pa.getOrCreateAccessPlug(ufeItemSphere, '', Sdf.ValueTypeNames.Matrix4d )
        
        cachingScope.waitForCache()
        cachingScope.checkValidFrames(self.cache_allFrames)
        
        # Validate that DAG transformation is applied when reading world space matrix from USD
        cmds.currentTime(1)
        v0 = cmds.getAttr('{}.{}'.format(nodeDagPath,worldMatrixPlugSphere))
        self.assertEqual(v0, [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 5.0, 0.0, 0.0, 1.0])
        
        cmds.currentTime(100)
        v0 = cmds.getAttr('{}.{}'.format(nodeDagPath,worldMatrixPlugSphere))
        self.assertEqual(v0, [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, -5.0, 5.0, 0.0, 1.0])
        
        # Animate the proxy shape
        cmds.select(transform)
        
        cmds.currentTime(1)
        cmds.move(0,-2,0, relative=True)
        
        # Move should have invalidated entire cache since we moved static object
        cachingScope.checkValidFrames(self.cache_empty)
        
        cmds.setKeyframe('{}.t'.format(transform))
        cachingScope.waitForCache()
        cachingScope.checkValidFrames(self.cache_allFrames)
        
        cmds.currentTime(50)
        cmds.move(-2,0,0, relative=True)
        
        # We already have one key dropped, so we shouldn't invalidate cache on this move
        cachingScope.checkValidFrames(self.cache_allFrames)
        
        cmds.setKeyframe('{}.t'.format(transform))
        # We just added a new key, now cache should be invalid
        cachingScope.checkValidFrames(self.cache_empty)
    
    def validateKeyframeWithCommands(self, cachingScope):
        """
        This helper method will validate keying workflow (manipulation and setting keys to manipulated values)
        """
        nodeDagPath, stage = createProxyFromFile(self.testAnimatedHierarchyUsdFile)
        
        # Get UFE item and select it
        ufeItemParent = createUfeSceneItem(nodeDagPath,'/ParentA')
        selectUfeItems(ufeItemParent)

        # We are going to manipulate animated prim. Let's make sure this opinion can be authored
        # since currently UFE will author attribute values at default time which won't override
        # attributes with time sampled data. Switching to session layer allows such manipulation
        # to override time sampled data from root layer.
        stage.SetEditTarget(stage.GetSessionLayer())
        
        # Current limitation requires access plugs to be created before we start manipulating and keying
        translatePlug = pa.getOrCreateAccessPlug(ufeItemParent, usdAttrName='xformOp:translate')
        rotatePlug = pa.getOrCreateAccessPlug(ufeItemParent, usdAttrName='xformOp:rotateXYZ')
        cmds.currentTime(1) # trigger compute to fill the data
        
        cachingScope.waitForCache()
        cachingScope.checkValidFrames(self.cache_allFrames)
        
        # Manipulate using Maya and key (at frame 1)
        cmds.currentTime(1)
        cmds.move(0,-2,0, relative=True)
        cmds.rotate(0, 90, 0, relative=True, objectSpace=True, forceOrderXYZ=True)

        cachingScope.checkValidFrames(self.cache_empty)

        # Proxy accessor should pick up the manipulation and write it to output plugs
        # This is important to enable keying workflow
        self.validatePlugsEqual(nodeDagPath,
            [(translatePlug,(0.0, -2.0, 0.0)), (rotatePlug, (0.0, 90.0, 0.0))])
        
        pa.keyframeAccessPlug(ufeItemParent, 'xformOp:translate')
        pa.keyframeAccessPlug(ufeItemParent, 'xformOp:rotateXYZ')
     
        # Double check that nothing changed after keying
        # Keying will create a new curve and connect the plug making
        # accessor plug an input now (since it has a connection)
        self.validatePlugsEqual(nodeDagPath,
            [(translatePlug,(0.0, -2.0, 0.0)), (rotatePlug, (0.0, 90.0, 0.0))])

        cachingScope.waitForCache()
        cachingScope.checkValidFrames(self.cache_allFrames)

        # Manipulate and drop a key at frame 50
        cmds.currentTime(50)
        cmds.move(-20, -18, -20, relative=False)
        cmds.rotate(90, 0, 0, relative=False)
        
        pa.keyframeAccessPlug(ufeItemParent, 'xformOp:translate')
        pa.keyframeAccessPlug(ufeItemParent, 'xformOp:rotateXYZ')
        
        cachingScope.checkValidFrames(self.cache_empty)
        cachingScope.waitForCache()
        cachingScope.checkValidFrames(self.cache_allFrames)
        
        # Manipulate and drop a key at frame 100
        cmds.currentTime(100)
        cmds.move(10, -18, 10, relative=False)
        cmds.rotate(90, 45, 45, relative=False)
        
        pa.keyframeAccessPlug(ufeItemParent, 'xformOp:translate')
        pa.keyframeAccessPlug(ufeItemParent, 'xformOp:rotateXYZ')
        
        cachingScope.checkValidFrames(self.cache_empty)
        cachingScope.waitForCache()
        cachingScope.checkValidFrames(self.cache_allFrames)
        
        # Last pass over keys to validate animation
        cmds.currentTime(1)
        self.validatePlugsEqual(nodeDagPath,
            [(translatePlug,(0.0, -2.0, 0.0)), (rotatePlug, (0.0, 90.0, 0.0))])
        
        cmds.currentTime(50)
        self.validatePlugsEqual(nodeDagPath,
            [(translatePlug,(-20.0, -18.0, -20.0)), (rotatePlug, (90.0, 00.0, 0.0))])

        cmds.currentTime(100)
        self.validatePlugsEqual(nodeDagPath,
            [(translatePlug,(10.0, -18.0, 10.0)), (rotatePlug, (90.0, 45.0, 45.0))])
            
    def validateKeyframeWithUFE(self, cachingScope):
        """
        This helper method will validate keying workflow (manipulation using UFE interface and setting keys to manipulated values)
        """
        nodeDagPath, stage = createProxyFromFile(self.testAnimatedHierarchyUsdFile)
        
        # Get UFE item and select it
        ufeItemParent = createUfeSceneItem(nodeDagPath,'/ParentA')
        
        # Current limitation requires access plugs to be created before we start manipulating and keying
        translatePlug = pa.getOrCreateAccessPlug(ufeItemParent, usdAttrName='xformOp:translate')
        rotatePlug = pa.getOrCreateAccessPlug(ufeItemParent, usdAttrName='xformOp:rotateXYZ')
        cmds.currentTime(1) # trigger compute to fill the data
        
        cachingScope.waitForCache()
        cachingScope.checkValidFrames(self.cache_allFrames)
        
        # Manipulate using UFE and key (at frame 1)
        cmds.currentTime(1)

        ufeTransform3d = ufe.Transform3d.transform3d(ufeItemParent)
        v0 = ufeTransform3d.translation().vector
        v1 = ufeTransform3d.rotation().vector
        self.assertEqual(v0, [0.0, 0.0, 0.0])
        self.assertEqual(v1, [0.0, 0.0, 0.0])

        ufeTransform3d.translate(0.0, -2.0, 0.0)
        ufeTransform3d.rotate(0.0, 90.0, 0.0)

        # There is no key, so this should have invalidated the cache
        cachingScope.checkValidFrames(self.cache_empty)

        # Proxy accessor should pick up the manipulation and write it to output plugs
        # This is important to enable keying workflow
        self.validatePlugsEqual(nodeDagPath,
           [(translatePlug,(0.0, -2.0, 0.0)), (rotatePlug, (0.0, 90.0, 0.0))])

        pa.keyframeAccessPlug(ufeItemParent, 'xformOp:translate')
        pa.keyframeAccessPlug(ufeItemParent, 'xformOp:rotateXYZ')

        # Double check that nothing changed after keying
        # Keying will create a new curve and connect the plug making
        # accessor plug an input now (since it has a connection)
        self.validatePlugsEqual(nodeDagPath,
           [(translatePlug,(0.0, -2.0, 0.0)), (rotatePlug, (0.0, 90.0, 0.0))])

        cachingScope.waitForCache()
        cachingScope.checkValidFrames(self.cache_allFrames)

        # Manipulate and drop a key at frame 50
        cmds.currentTime(50)
        ufeTransform3d.translate(-20.0, -18.0, -20.0)
        ufeTransform3d.rotate(90.0, 0.0, 0.0)

        pa.keyframeAccessPlug(ufeItemParent, 'xformOp:translate')
        pa.keyframeAccessPlug(ufeItemParent, 'xformOp:rotateXYZ')

        cachingScope.checkValidFrames(self.cache_empty)
        cachingScope.waitForCache()
        cachingScope.checkValidFrames(self.cache_allFrames)

        # Manipulate and drop a key at frame 100
        cmds.currentTime(100)
        ufeTransform3d.translate(-10.0, -18.0, -10.0)
        ufeTransform3d.rotate(90.0, 45.0, 45.0)

        pa.keyframeAccessPlug(ufeItemParent, 'xformOp:translate')
        pa.keyframeAccessPlug(ufeItemParent, 'xformOp:rotateXYZ')

        cachingScope.checkValidFrames(self.cache_empty)
        cachingScope.waitForCache()
        cachingScope.checkValidFrames(self.cache_allFrames)

        # Last pass over keys to validate animation
        cmds.currentTime(1)
        self.validatePlugsEqual(nodeDagPath,
           [(translatePlug,(0.0, -2.0, 0.0)), (rotatePlug, (0.0, 90.0, 0.0))])

        cmds.currentTime(50)
        self.validatePlugsEqual(nodeDagPath,
           [(translatePlug,(-20.0, -18.0, -20.0)), (rotatePlug, (90.0, 00.0, 0.0))])

        cmds.currentTime(100)
        self.validatePlugsEqual(nodeDagPath,
           [(translatePlug,(10.0, -18.0, 10.0)), (rotatePlug, (90.0, 45.0, 45.0))])
    
    def validateKeyframeWithUSD(self, cachingScope):
        """
        This helper method will validate keying workflow (manipulation using USD interface and setting keys to manipulated values)
        """
        nodeDagPath, stage = createProxyFromFile(self.testAnimatedHierarchyUsdFile)
        
        # Get UFE item and select it
        ufeItemParent = createUfeSceneItem(nodeDagPath,'/ParentA')
        
        path = Sdf.Path('/ParentA')
        usdPrim = stage.GetPrimAtPath(path)
        self.assertTrue(usdPrim)
        
        usdTranslateAttr = usdPrim.GetAttribute('xformOp:translate')
        self.assertTrue(usdTranslateAttr.IsDefined())
        usdRotateAttr = usdPrim.GetAttribute('xformOp:rotateXYZ')
        self.assertTrue(usdRotateAttr.IsDefined())
        
        # Current limitation requires access plugs to be created before we start manipulating and keying
        translatePlug = pa.getOrCreateAccessPlug(ufeItemParent, usdAttrName='xformOp:translate')
        rotatePlug = pa.getOrCreateAccessPlug(ufeItemParent, usdAttrName='xformOp:rotateXYZ')
        cmds.currentTime(1) # trigger compute to fill the data
        
        cachingScope.waitForCache()
        cachingScope.checkValidFrames(self.cache_allFrames)
        
        # Manipulate using USD and key (at frame 1)
        cmds.currentTime(1)
        timeCode = Usd.TimeCode.Default() #Usd.TimeCode(1.0) # We are picking candidates from default time!
        usdTranslateAttr.Set((0.0, -2.0, 0.0), timeCode)
        usdRotateAttr.Set((0.0, 90.0, 0.0), timeCode)

        # There is no key, so this should have invalidated the cache
        cachingScope.checkValidFrames(self.cache_empty)

        pa.keyframeAccessPlug(ufeItemParent, 'xformOp:translate')
        pa.keyframeAccessPlug(ufeItemParent, 'xformOp:rotateXYZ')

        # Double check that nothing changed after keying
        # Keying will create a new curve and connect the plug making
        # accessor plug an input now (since it has a connection)
        self.validatePlugsEqual(nodeDagPath,
           [(translatePlug,(0.0, -2.0, 0.0)), (rotatePlug, (0.0, 90.0, 0.0))])

        cachingScope.waitForCache()
        cachingScope.checkValidFrames(self.cache_allFrames)

        # Manipulate and drop a key at frame 50
        cmds.currentTime(50)
        timeCode = Usd.TimeCode.Default() #Usd.TimeCode(50.0) # We are picking candidates from default time!
        usdTranslateAttr.Set((-20.0, -18.0, -20.0), timeCode)
        usdRotateAttr.Set((90.0, 0.0, 0.0), timeCode)

        pa.keyframeAccessPlug(ufeItemParent, 'xformOp:translate')
        pa.keyframeAccessPlug(ufeItemParent, 'xformOp:rotateXYZ')

        cachingScope.checkValidFrames(self.cache_empty)
        cachingScope.waitForCache()
        cachingScope.checkValidFrames(self.cache_allFrames)

        # Manipulate and drop a key at frame 100
        cmds.currentTime(100)
        timeCode = Usd.TimeCode.Default() #Usd.TimeCode(100.0) # We are picking candidates from default time!
        usdTranslateAttr.Set((-10.0, -18.0, -10.0), timeCode)
        usdRotateAttr.Set((90.0, 45.0, 45.0), timeCode)

        pa.keyframeAccessPlug(ufeItemParent, 'xformOp:translate')
        pa.keyframeAccessPlug(ufeItemParent, 'xformOp:rotateXYZ')

        cachingScope.checkValidFrames(self.cache_empty)
        cachingScope.waitForCache()
        cachingScope.checkValidFrames(self.cache_allFrames)

        # Last pass over keys to validate animation
        cmds.currentTime(1)
        self.validatePlugsEqual(nodeDagPath,
           [(translatePlug,(0.0, -2.0, 0.0)), (rotatePlug, (0.0, 90.0, 0.0))])

        cmds.currentTime(50)
        self.validatePlugsEqual(nodeDagPath,
           [(translatePlug,(-20.0, -18.0, -20.0)), (rotatePlug, (90.0, 00.0, 0.0))])

        cmds.currentTime(100)
        self.validatePlugsEqual(nodeDagPath,
           [(translatePlug,(10.0, -18.0, 10.0)), (rotatePlug, (90.0, 45.0, 45.0))])
    
    def validateDisconnect(self, cachingScope):
        """
        Validate that accessor clears temporary data after disconnecting the input
        """
        nodeDagPath, stage = createProxyFromFile(self.testAnimatedHierarchyUsdFile)
        
        # Animate accessor plugs (they will become inputs to the stage owned by proxy)
        cmds.spaceLocator()
        srcLocatorDagPath = cmds.ls(sl=True,l=True)[0]
        cmds.setKeyframe( '{}.tz'.format(srcLocatorDagPath), time=1.0, value=0.0 )
        cmds.setKeyframe( '{}.tz'.format(srcLocatorDagPath), time=100.0, value=10.0)
        
        # Get UFE items
        ufeItemParent = createUfeSceneItem(nodeDagPath,'/ParentA')
        ufeItemSphere = createUfeSceneItem(nodeDagPath,'/ParentA/Sphere')
        ufeItemSrcLocator = createUfeSceneItem(srcLocatorDagPath)
        
        # Create accessor plugs
        translatePlugParent = pa.getOrCreateAccessPlug(ufeItemParent, usdAttrName='xformOp:translate')
        worldMatrixPlugSphere = pa.getOrCreateAccessPlug(ufeItemSphere, '', Sdf.ValueTypeNames.Matrix4d )
        
        pa.connectItems(ufeItemSrcLocator, ufeItemParent, [('translate','xformOp:translate')])
        
        cachingScope.checkValidFrames(self.cache_empty)
        cachingScope.waitForCache()
        cachingScope.checkValidFrames(self.cache_allFrames)
        
        cmds.currentTime(1)
        v1 = cmds.getAttr('{}.{}'.format(nodeDagPath,worldMatrixPlugSphere))
        self.assertEqual(v1, [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 5.0, 0.0, 0.0, 1.0])
        
        cmds.currentTime(100)
        v1 = cmds.getAttr('{}.{}'.format(nodeDagPath,worldMatrixPlugSphere))
        self.assertVectorAlmostEqual(v1, [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, -5.0, 0.0, 10.0, 1.0])
        
        # Validate session layer
        dumpSessionLayer = stage.GetSessionLayer().ExportToString()
        # We will have many frames stored, but we only check last one (the rest is not really important for this test)
        self.assertIn("double3 xformOp:translate.timeSamples = {\n",dumpSessionLayer)
        self.assertIn("100: (0, 0, 10),\n",dumpSessionLayer)
            
        # Disconnect the attributes should clear temp opinions in session layers
        cmds.disconnectAttr('{}.t'.format(srcLocatorDagPath), '{}.{}'.format(nodeDagPath,translatePlugParent))
        
        cachingScope.checkValidFrames(self.cache_empty)
        cachingScope.waitForCache()
        cachingScope.checkValidFrames(self.cache_allFrames)
        
        dumpSessionLayer = stage.GetSessionLayer().ExportToString()
        self.assertNotIn("double3 xformOp:translate.timeSamples = {\n",dumpSessionLayer)
      
    def validateMatrixOps(self, cachingScope):
        """
        Validate that accessor works correctly with matrix ops
        """
        nodeDagPath, stage = createProxyFromFile(self.testAnimatedHierarchyUsdFile)
        stage.GetRootLayer().ImportFromString('''#usda 1.0
          (
              defaultPrim = "pCube1"
              upAxis = "Y"
          )

          def Cube "pCube1" (
              kind = "component"
          )
          {
              matrix4d xformOp:transform:offset = ((1,0,0,0),(0,1,0,0),(0,0,1,0),(0, 5, 10,1))
              uniform token[] xformOpOrder = ["xformOp:transform:offset"]
          }
        ''')

        # Get UFE items
        ufeItem = createUfeSceneItem(nodeDagPath,'/pCube1')

        # Create accessor plugs
        matrixPlug = pa.getOrCreateAccessPlug(ufeItem, usdAttrName='xformOp:transform:offset')

        cachingScope.waitForCache()
        cachingScope.checkValidFrames(self.cache_allFrames)

        # Validate output accessor plugs
        cmds.currentTime(1)
        v0 = cmds.getAttr('{}.{}'.format(nodeDagPath,matrixPlug))
        self.assertEqual(v0, [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 5.0, 10.0, 1.0])
        
        # Create a locator to drive matrix op
        # and apply offset on its translateY
        cmds.spaceLocator()
        srcNodeDagPath = cmds.ls(sl=True,l=True)[0]
        cmds.setAttr('{}.ty'.format(srcNodeDagPath), 3)
        
        # Connect src to drive matrix op
        cmds.connectAttr('{}.worldMatrix[0]'.format(srcNodeDagPath), '{}.{}'.format(nodeDagPath,matrixPlug))
        
        # Validate
        cachingScope.checkValidFrames(self.cache_empty)
        cachingScope.waitForCache()
        cachingScope.checkValidFrames(self.cache_allFrames)
        
        cmds.currentTime(1)
        v0 = cmds.getAttr('{}.{}'.format(nodeDagPath,matrixPlug))
        self.assertEqual(v0, [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 3.0, 0.0, 1.0])
    
    def validateRecursiveCompute(self, cachingScope):
        """
        Create parent constraint between two USD items. Such setup will make cyclic
        dependency between proxy shape inputs and outputs, i.e. constraint requires
        target local space attributes and world space attributes. To make this setup even more
        complex, we make parent of the target animated with Maya's animation curves. This
        way nested compute has to go outside of proxy shape when computing parent of the
        target.
        """
        nodeDagPath,stage = createProxyFromFile(self.testAnimatedHierarchyUsdFile)
        
        # Get UFE items
        ufeItemParent = createUfeSceneItem(nodeDagPath,'/ParentA')
        ufeItem = createUfeSceneItem(nodeDagPath,'/ParentA/Sphere')
        ufeTarget = createUfeSceneItem(nodeDagPath,'/ParentA/Cube')
        
        # Animate with animation curve parent rotation to create additional dependency on Maya's
        # compute
        rotatePlugParent = pa.getOrCreateAccessPlug(ufeItemParent, usdAttrName='xformOp:rotateXYZ')
        cmds.setKeyframe( '{}.{}'.format(nodeDagPath,rotatePlugParent), time=1.0, value=0.0 )
        cmds.setKeyframe( '{}.{}'.format(nodeDagPath,rotatePlugParent), time=100.0, value=90.0)
        
        # Parent
        pa.parentConstraintItems(ufeItem,ufeTarget)
        
        # Get accessor plugs (created by parent constraint method)
        translatePlug = pa.getOrCreateAccessPlug(ufeItem, usdAttrName='xformOp:translate')
        rotatePlug = pa.getOrCreateAccessPlug(ufeItem, usdAttrName='xformOp:rotateXYZ')
        
        # Get accessor to world matrix for ufeItem to validate parent animation
        worldMatrixPlug = pa.getOrCreateAccessPlug(ufeItem, '', Sdf.ValueTypeNames.Matrix4d)
        
        # Validate
        cachingScope.checkValidFrames(self.cache_empty)
        cachingScope.waitForCache()
        cachingScope.checkValidFrames(self.cache_allFrames)
        
        cmds.currentTime(1)
        self.validatePlugsAlmostEqual(nodeDagPath, [(translatePlug,(0.0, 0.0, 5.0)), (rotatePlug, (0.0, 0.0, 0.0))])
        v0 = cmds.getAttr('{}.{}'.format(nodeDagPath,worldMatrixPlug))
        self.assertVectorAlmostEqual(v0, [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 5.0, 1.0])
        
        cmds.currentTime(100)
        self.validatePlugsAlmostEqual(nodeDagPath, [(translatePlug,(0.0, 0.0, -5.0)), (rotatePlug, (0.0, 0.0, 0.0))])
        v0 = cmds.getAttr('{}.{}'.format(nodeDagPath,worldMatrixPlug))
        self.assertVectorAlmostEqual(v0, [0.0, 0.0, -1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, -5.0, 5.0, 0.0, 1.0])
    
    ###################################################################################
    def testOutput_NoCaching(self):
        """
        Validate that accessor can output attributes and worldspace matrix from the stage
        Cached playback is disabled in this test.
        """
        cmds.file(new=True, force=True)
        with NonCachingScope(self) as thisScope:
            thisScope.verifyScopeSetup()
            self.validateOutput(thisScope)

    def testOutput_Caching(self):
        """
        Validate that accessor can output attributes and worldspace matrix from the stage
        Cached playback is disabled in this test.
        """
        cmds.file(new=True, force=True)
        with CachingScope(self) as thisScope:
            thisScope.verifyScopeSetup()
            self.validateOutput(thisScope)

    def testTransformedOutput_NoCaching(self):
        """
        Validate that accessor will respect shape transform when writing world space outputs.
        Cached playback is disabled in this test.
        """
        cmds.file(new=True, force=True)
        with NonCachingScope(self) as thisScope:
            thisScope.verifyScopeSetup()
            self.validateTransformedOutput(thisScope)

    def testTransformedOutput_Caching(self):
        """
        Validate that accessor will respect shape transform when writing world space outputs.
        Cached playback is ENABLED in this test.
        """
        cmds.file(new=True, force=True)
        with CachingScope(self) as thisScope:
            thisScope.verifyScopeSetup()
            self.validateTransformedOutput(thisScope)
    
    def testInput_NoCaching(self):
        """
        The that accessor can write data to the stage and it's propagated correctly to:
        - output plugs
        - UFE interfaces
        Cached playback is disabled in this test.
        """
        cmds.file(new=True, force=True)
        with NonCachingScope(self) as thisScope:
            thisScope.verifyScopeSetup()
            self.validateInput(thisScope)
  
    def testInput_Caching(self):
        """
        The that accessor can write data to the stage and it's propagated correctly to:
        - output plugs
        - UFE interfaces
        Cached playback is ENABLED in this test.
        """
        cmds.file(new=True, force=True)
        with CachingScope(self) as thisScope:
            thisScope.verifyScopeSetup()
            self.validateInput(thisScope)
        
    def testParentingDagObjectUnderUsdPrim_NoCaching(self):
        """
        Test parenting of dag object under usd prim.
        Cached playback is disabled in this test.
        """
        cmds.file(new=True, force=True)
        with NonCachingScope(self) as thisScope:
            thisScope.verifyScopeSetup()
            self.validateParentingDagObjectUnderUsdPrim(thisScope)
 
    def testParentingDagObjectUnderUsdPrim_Caching(self):
        """
        Test parenting of dag object under usd prim.
        Cached playback is ENABLED in this test.
        """
        cmds.file(new=True, force=True)
        with CachingScope(self) as thisScope:
            thisScope.verifyScopeSetup()
            self.validateParentingDagObjectUnderUsdPrim(thisScope)
 
    def testPassiveManipulation_NoCaching(self):
        """
        Test manipulation of accessor plug which has incoming curve connection.
        Cached playback is disabled in this test.
        """
        cmds.file(new=True, force=True)
        with NonCachingScope(self) as thisScope:
            thisScope.verifyScopeSetup()
            self.validatePassivelyAffectedReset(thisScope)
            
    def testPassiveManipulation_Caching(self):
        """
        Test manipulation of accessor plug which has incoming curve connection.
        Cached playback is ENABLED in this test.
        """
        cmds.file(new=True, force=True)
        with CachingScope(self) as thisScope:
            thisScope.verifyScopeSetup()
            self.validatePassivelyAffectedReset(thisScope)

    def testDagManipulation_NoCaching(self):
        """
        This helper method validate proper DAG invalidation during manipulation
        Cached playback is disabled in this test.
        """
        cmds.file(new=True, force=True)
        with NonCachingScope(self) as thisScope:
            thisScope.verifyScopeSetup()
            self.validateDagManipulation(thisScope)
            
    def testDagManipulation_Caching(self):
        """
        This helper method validate proper DAG invalidation during manipulation
        Cached playback is ENABLED in this test.
        """
        cmds.file(new=True, force=True)
        with CachingScope(self) as thisScope:
            thisScope.verifyScopeSetup()
            self.validateDagManipulation(thisScope)

    def testKeyframeWithCommands_NoCaching(self):
        """
        Test keying with cached playback disabled
        """
        cmds.file(new=True, force=True)
        with NonCachingScope(self) as thisScope:
            thisScope.verifyScopeSetup()
            self.validateKeyframeWithCommands(thisScope)
            
    def testKeyframeWithCommands_Caching(self):
        """
        Test keying with cached playback ENABLED
        """
        cmds.file(new=True, force=True)
        with CachingScope(self) as thisScope:
            thisScope.verifyScopeSetup()
            self.validateKeyframeWithCommands(thisScope)
            
    def testSerializationASCII_NoCache(self):
        """
        Test serialization in ascii maya file format
        Cached playback is disabled in this test.
        """
        cmds.file(new=True, force=True)
        with NonCachingScope(self) as thisScope:
            thisScope.verifyScopeSetup()
            self.validateSerialization('testSerializationASCII.ma', 'mayaAscii')

    def testSerializationBinary_NoCache(self):
        """
        Test serialization in binary maya file format
        Cached playback is disabled in this test.
        """
        cmds.file(new=True, force=True)
        with NonCachingScope(self) as thisScope:
            thisScope.verifyScopeSetup()
            self.validateSerialization('testSerializationBinary.mb', 'mayaBinary')
   
    def testOutputForInMemoryRootLayer_NoCache(self):
       """
       Validate that accessor can output attributes and worldspace matrix from the stage.
       This helper method is creating stage with in-memory root layer.
       Cached playback is disabled in this test.
       """
       cmds.file(new=True, force=True)
       with NonCachingScope(self) as thisScope:
           thisScope.verifyScopeSetup()
           self.validateOutputForInMemoryRootLayer(thisScope)
           
    def testOutputForInMemoryRootLayer_Cache(self):
        """
        Validate that accessor can output attributes and worldspace matrix from the stage.
        This helper method is creating stage with in-memory root layer.
        Cached playback is ENABLED in this test.
        """
        cmds.file(new=True, force=True)
        with CachingScope(self) as thisScope:
            thisScope.verifyScopeSetup()
            self.validateOutputForInMemoryRootLayer(thisScope)
            
    @unittest.skip("Need to investigate why this test is not failing when run in Maya with GUI")
    def testKeyframeWithUFE_NoCaching(self):
        """
        This helper method will validate keying workflow (manipulation using UFE interface and setting keys to manipulated values)
        Cached playback is disabled in this test.
        """
        cmds.file(new=True, force=True)
        with NonCachingScope(self) as thisScope:
            thisScope.verifyScopeSetup()
            self.validateKeyframeWithUFE(thisScope)

    @unittest.skip("Need to investigate why directly setting values with USD doesn't work. Could be a bug in the test")
    def testKeyframeWithUSD_NoCaching(self):
        """
        This helper method will validate keying workflow (manipulation using USD interface and setting keys to manipulated values)
        Cached playback is disabled in this test.
        """
        cmds.file(new=True, force=True)
        with NonCachingScope(self) as thisScope:
            thisScope.verifyScopeSetup()
            self.validateKeyframeWithUSD(thisScope)

    def testDisconnect_NoCaching(self):
        """
        Validate that accessor clears temporary data after disconnecting the input
        Cached playback is disabled in this test.
        """
        cmds.file(new=True, force=True)
        with NonCachingScope(self) as thisScope:
            thisScope.verifyScopeSetup()
            self.validateDisconnect(thisScope)

    def testDisconnect_Caching(self):
        """
        Validate that accessor clears temporary data after disconnecting the input
        Cached playback is ENABLED in this test.
        """
        cmds.file(new=True, force=True)
        with CachingScope(self) as thisScope:
            thisScope.verifyScopeSetup()
            self.validateDisconnect(thisScope)

    def testMatrixOp_NoCaching(self):
        """
        Validate that accessor works correctly with matrix ops
        Cached playback is disabled in this test.
        """
        cmds.file(new=True, force=True)
        with NonCachingScope(self) as thisScope:
            thisScope.verifyScopeSetup()
            self.validateMatrixOps(thisScope)

    def testMatrixOp_Caching(self):
        """
        Validate that accessor works correctly with matrix ops
        Cached playback is ENABLED in this test.
        """
        cmds.file(new=True, force=True)
        with CachingScope(self) as thisScope:
            thisScope.verifyScopeSetup()
            self.validateMatrixOps(thisScope)
            
    def testRecursiveCompute_NoCaching(self):
        """
        Validate that cyclic compute for parent constraints works.
        Cached playback is disabled in this test.
        """
        cmds.file(new=True, force=True)
        with NonCachingScope(self) as thisScope:
            thisScope.verifyScopeSetup()
            self.validateRecursiveCompute(thisScope)

    def testRecursiveCompute_Caching(self):
        """
        Validate that cyclic compute for parent constraints works.
        Cached playback is ENABLED in this test.
        """
        cmds.file(new=True, force=True)
        with CachingScope(self) as thisScope:
            thisScope.verifyScopeSetup()
            self.validateRecursiveCompute(thisScope)
